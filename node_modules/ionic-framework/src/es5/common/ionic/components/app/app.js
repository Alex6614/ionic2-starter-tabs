"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

exports.ionicBootstrap = ionicBootstrap;

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _angular2Angular2 = require('angular2/angular2');

var _angular2Router = require('angular2/router');

var _configConfig = require('../../config/config');

var _platformPlatform = require('../../platform/platform');

var _utilClickBlock = require('../../util/click-block');

var _utilDom = require('../../util/dom');

var dom = _interopRequireWildcard(_utilDom);

var _tapClickTapClick = require('../tap-click/tap-click');

var _actionSheetActionSheet = require('../action-sheet/action-sheet');

var _modalModal = require('../modal/modal');

var _popupPopup = require('../popup/popup');

var _formFocusHolder = require('../form/focus-holder');

var _utilEvents = require('../../util/events');

var _navNavRegistry = require('../nav/nav-registry');

var _translationTranslate = require('../../translation/translate');

/**
 * @name IonicApp
 * @description
 * Service exposing the Ionic app level API.
 *
 * @usage
 * ```js
 *  @App({
 *    templateUrl: '/app/app.html',
 *  })
 *  class MyApp {
 *
 *    constructor(app: IonicApp) {
 *      this.app = app;
 *    }
 *  }
 *  ```
 * Note: Ionic sets `ion-app` as the selector for the app. Setting a custom selector will override this and cause CSS problems.
 *
 */
var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2:
            return decorators.reduceRight(function (o, d) {
                return d && d(o) || o;
            }, target);
        case 3:
            return decorators.reduceRight(function (o, d) {
                return (d && d(target, key), void 0);
            }, void 0);
        case 4:
            return decorators.reduceRight(function (o, d) {
                return d && d(target, key, o) || o;
            }, desc);
    }
};
var __metadata = undefined && undefined.__metadata || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

var IonicApp = (function () {
    /**
     * TODO
     */

    function IonicApp() {
        _classCallCheck(this, IonicApp);

        this.overlays = [];
        this._disTime = 0;
        this._trnsTime = 0;
        // Our component registry map
        this.components = {};
    }

    /**
     * Bind some global events and publish on the 'app' channel
     */

    _createClass(IonicApp, [{
        key: "bindEvents",
        value: function bindEvents(events) {
            window.addEventListener('online', function (event) {
                events.publish('app:online', event);
            }, false);
            window.addEventListener('offline', function (event) {
                events.publish('app:offline', event);
            }, false);
            window.addEventListener('orientationchange', function (event) {
                events.publish('app:rotated', event);
            });
        }

        /**
         * TODO
         * @param {Object} appRef  TODO
         */
    }, {
        key: "load",
        value: function load(appRef) {
            this.ref(appRef);
            this._zone = appRef.injector.get(_angular2Angular2.NgZone);
        }

        /**
         * TODO
         * @param {TODO=} val  TODO
         * @return {TODO} TODO
         */
    }, {
        key: "focusHolder",
        value: function focusHolder(val) {
            if (arguments.length) {
                this._fcsHldr = val;
            }
            return this._fcsHldr;
        }

        /**
         * Sets the document title.
         * @param {string} val  Value to set the document title to.
         */
    }, {
        key: "title",
        value: function title(val) {
            // TODO: User angular service
            document.title = val;
        }

        /**
         * Sets if the app is currently enabled or not, meaning if it's
         * available to accept new user commands. For example, this is set to `false`
         * while views transition, a modal slides up, an action-sheet
         * slides up, etc. After the transition completes it is set back to `true`.
         * @param {bool} isEnabled
         * @param {bool} fallback  When `isEnabled` is set to `false`, this argument
         * is used to set the maximum number of milliseconds that app will wait until
         * it will automatically enable the app again. It's basically a fallback incase
         * something goes wrong during a transition and the app wasn't re-enabled correctly.
         */
    }, {
        key: "setEnabled",
        value: function setEnabled(isEnabled) {
            var fallback = arguments.length <= 1 || arguments[1] === undefined ? 700 : arguments[1];

            this._disTime = isEnabled ? 0 : Date.now() + fallback;
            (0, _utilClickBlock.ClickBlock)(!isEnabled, fallback + 100);
        }

        /**
         * Boolean if the app is actively enabled or not.
         * @return {bool}
         */
    }, {
        key: "isEnabled",
        value: function isEnabled() {
            return this._disTime < Date.now();
        }
    }, {
        key: "setTransitioning",
        value: function setTransitioning(isTransitioning) {
            var fallback = arguments.length <= 1 || arguments[1] === undefined ? 700 : arguments[1];

            this._trnsTime = isTransitioning ? Date.now() + fallback : 0;
        }

        /**
         * Boolean if the app is actively transitioning or not.
         * @return {bool}
         */
    }, {
        key: "isTransitioning",
        value: function isTransitioning() {
            return this._trnsTime > Date.now();
        }

        /**
         * TODO
         * @param {TODO=} val  TODO
         * @return TODO
         */
    }, {
        key: "ref",
        value: function ref(val) {
            if (arguments.length) {
                this._ref = val;
            }
            return this._ref;
        }

        /**
         * TODO
         * @return TODO
         */
    }, {
        key: "zoneRun",

        /**
         * TODO
         * @param {Function} fn  TODO
         */
        value: function zoneRun(fn) {
            this._zone.run(fn);
        }

        /**
         * TODO
         * @param {Function} fn  TODO
         */
    }, {
        key: "zoneRunOutside",
        value: function zoneRunOutside(fn) {
            this._zone.runOutsideAngular(fn);
        }

        /**
         * Register a known component with a key, for easy lookups later.
         * @param {TODO} id  The id to use to register the component
         * @param {TODO} component  The component to register
         */
    }, {
        key: "register",
        value: function register(id, component) {
            if (this.components[id] && this.components[id] !== component) {
                console.error('Component id "' + id + '" already registered.');
            }
            this.components[id] = component;
        }

        /**
         * Unregister a known component with a key.
         * @param {TODO} id  The id to use to unregister
         */
    }, {
        key: "unregister",
        value: function unregister(id) {
            delete this.components[id];
        }

        /**
         * Get a registered component with the given type (returns the first)
         * @param {Object} cls the type to search for
         * @return the matching component, or undefined if none was found
         */
    }, {
        key: "getRegisteredComponent",
        value: function getRegisteredComponent(cls) {
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = this.components[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var component = _step.value;

                    if (component instanceof cls) {
                        return component;
                    }
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator["return"]) {
                        _iterator["return"]();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
        }

        /**
         * Get the component for the given key.
         * @param {TODO} key  TODO
         * @return {TODO} TODO
         */
    }, {
        key: "getComponent",
        value: function getComponent(id) {
            return this.components[id];
        }

        /**
         * Create and append the given component into the root
         * element of the app.
         *
         * @param {TODO} componentType the component to create and insert
         * @return {Promise} Promise that resolves with the ContainerRef created
         */
    }, {
        key: "appendComponent",
        value: function appendComponent(componentType) {
            return this.rootAnchor.append(componentType);
        }

        /**
         * If val is defined, specifies whether app text is RTL.  If val is undefined
         * returns whether app text is RTL.
         *
         * @param {boolean=} val  Boolean specifying whether text is RTL or not.
         * @returns {boolean} true if app text is RTL, false if otherwise.
         */
    }, {
        key: "isRTL",
        value: function isRTL(val) {
            if (arguments.length) {
                this._rtl = val;
            }
            return this._rtl;
        }
    }, {
        key: "injector",
        get: function get() {
            return this._ref.injector;
        }
    }]);

    return IonicApp;
})();

exports.IonicApp = IonicApp;

var RootAnchor = (function () {
    function RootAnchor(app, elementRef, loader) {
        _classCallCheck(this, RootAnchor);

        this.elementRef = elementRef;
        this.loader = loader;
        app.rootAnchor = this;
    }

    _createClass(RootAnchor, [{
        key: "append",
        value: function append(componentType) {
            return this.loader.loadNextToLocation(componentType, this.elementRef)["catch"](function (err) {
                console.error(err);
            });
        }
    }]);

    return RootAnchor;
})();
RootAnchor = __decorate([(0, _angular2Angular2.Component)({
    selector: 'root-anchor'
}), (0, _angular2Angular2.View)({
    template: ''
}), __metadata('design:paramtypes', [IonicApp, typeof _angular2Angular2.ElementRef !== 'undefined' && _angular2Angular2.ElementRef || Object, typeof _angular2Angular2.DynamicComponentLoader !== 'undefined' && _angular2Angular2.DynamicComponentLoader || Object])], RootAnchor);
function initApp(window, document, config, platform) {
    // create the base IonicApp
    var app = new IonicApp();
    app.isRTL(document.dir == 'rtl');
    // load all platform data
    platform.url(window.location.href);
    platform.userAgent(window.navigator.userAgent);
    platform.navigatorPlatform(window.navigator.platform);
    platform.load(config);
    // copy default platform settings into the user config platform settings
    // user config platform settings should override default platform settings
    config.setPlatform(platform);
    // config and platform settings have been figured out
    // apply the correct CSS to the app
    applyBodyCss(document, config, platform);
    // prepare the ready promise to fire....when ready
    platform.prepareReady(config);
    setTimeout(function () {
        // start listening for resizes XXms after the app starts
        window.addEventListener('resize', function () {
            platform.windowResize();
        });
    }, 2500);
    return app;
}
/**
 * TODO
 *
 * @param {TODO} rootComponentType  TODO
 * @param {TODO} config  TODO
 * @return {Promise} TODO
 */

function ionicBootstrap(rootComponentType, views, config) {
    return new Promise(function (resolve) {
        try {
            (function () {
                // get the user config, or create one if wasn't passed in
                if (typeof config !== _configConfig.IonicConfig) {
                    config = new _configConfig.IonicConfig(config);
                }
                var platform = new _platformPlatform.IonicPlatform();
                // create the base IonicApp
                var app = initApp(window, document, config, platform);
                // TODO: probs need a better way to inject global injectables
                var tapClick = new _tapClickTapClick.TapClick(app, config, window, document);
                var actionSheet = new _actionSheetActionSheet.ActionSheet(app, config);
                var modal = new _modalModal.Modal(app, config);
                var popup = new _popupPopup.Popup(app, config);
                var events = new _utilEvents.Events();
                var translate = new _translationTranslate.Translate();
                var navRegistry = new _navNavRegistry.NavRegistry(views);
                app.bindEvents(events);
                // add injectables that will be available to all child components
                var appBindings = _angular2Angular2.Injector.resolve([(0, _angular2Angular2.bind)(IonicApp).toValue(app), (0, _angular2Angular2.bind)(_configConfig.IonicConfig).toValue(config), (0, _angular2Angular2.bind)(_platformPlatform.IonicPlatform).toValue(platform), (0, _angular2Angular2.bind)(_tapClickTapClick.TapClick).toValue(tapClick), (0, _angular2Angular2.bind)(_actionSheetActionSheet.ActionSheet).toValue(actionSheet), (0, _angular2Angular2.bind)(_modalModal.Modal).toValue(modal), (0, _angular2Angular2.bind)(_popupPopup.Popup).toValue(popup), (0, _angular2Angular2.bind)(_utilEvents.Events).toValue(events), _angular2Router.ROUTER_BINDINGS, (0, _angular2Angular2.bind)(_angular2Router.LocationStrategy).toClass(_angular2Router.HashLocationStrategy), (0, _angular2Angular2.bind)(_translationTranslate.Translate).toValue(translate), (0, _angular2Angular2.bind)(_navNavRegistry.NavRegistry).toValue(navRegistry)]);
                (0, _angular2Angular2.bootstrap)(rootComponentType, appBindings).then(function (appRef) {
                    app.load(appRef);
                    // Adding a anchor to add overlays off of...huh??
                    var elementRefs = appRef._hostComponent.hostView._view.elementRefs;
                    var lastElementRef = elementRefs[1];
                    var injector = lastElementRef.parentView._view.rootElementInjectors[0]._injector;
                    var loader = injector.get(_angular2Angular2.DynamicComponentLoader);
                    loader.loadNextToLocation(RootAnchor, lastElementRef).then(function () {
                        // append the focus holder if its needed
                        if (config.setting('keyboardScrollAssist')) {
                            app.appendComponent(_formFocusHolder.FocusHolder).then(function (ref) {
                                app.focusHolder(ref.instance);
                            });
                        }
                    })["catch"](function (err) {
                        console.error(err);
                    });
                    resolve(app);
                })["catch"](function (err) {
                    console.error('ionicBootstrap', err);
                });
            })();
        } catch (err) {
            console.error(err);
        }
    });
}

function applyBodyCss(document, config, platform) {
    var bodyEle = document.body;
    if (!bodyEle) {
        return dom.ready(function () {
            applyBodyCss(document, config, platform);
        });
    }
    var versions = platform.versions();
    platform.platforms().forEach(function (platformName) {
        // platform-ios
        var platformClass = 'platform-' + platformName;
        bodyEle.classList.add(platformClass);
        var platformVersion = versions[platformName];
        if (platformVersion) {
            // platform-ios9
            platformClass += platformVersion.major;
            bodyEle.classList.add(platformClass);
            // platform-ios9_3
            bodyEle.classList.add(platformClass + '_' + platformVersion.minor);
        }
    });
    // set the mode class name
    // ios
    bodyEle.classList.add(config.setting('mode'));
    // touch devices should not use :hover CSS pseudo
    // enable :hover CSS when the "hoverCSS" setting is not false
    if (config.setting('hoverCSS') !== false) {
        bodyEle.classList.add('enable-hover');
    }
    /**
    * Hairline Shim
    * Add the "hairline" CSS class name to the body tag
    * if the browser supports subpixels.
    */
    if (window.devicePixelRatio >= 2) {
        var hairlineEle = document.createElement('div');
        hairlineEle.style.border = '.5px solid transparent';
        bodyEle.appendChild(hairlineEle);
        if (hairlineEle.offsetHeight === 1) {
            bodyEle.classList.add('hairlines');
        }
        bodyEle.removeChild(hairlineEle);
    }
}